use crate::api::{get_blueprint_from_opt, get_read_from_opt};
use crate::api::partition::blueprint_set_partition;
use crate::installer::{BluePrint, Partition};
use crate::read::{get_read, Read};
use crate::storage::btrfs::{create_subvolume, mount_subvolume};
use crate::storage::{
    create_new_partition_table, create_new_partition_table_with_partition, format,
    format_unallocated, mount, umount, get_number_from_path
};
use duct::cmd;
use std::fs::{create_dir, create_dir_all};
use std::io::{Error, ErrorKind};
use std::path::Path;
use tea_arch_chroot_lib::resource::{FirmwareKind, MethodKind};
use tea_partition_api_lib::GetDiskInformation;

use tea_partition_generator::mkpart::Partgen;
use tea_partition_generator::mounting::{Mount, MountPoint};
use tea_partition_generator::os::Os;

fn force_umount() {
    // Ignore error if the mountpoint is not mounted
    let _ = cmd!("umount", "--recursive", "/tealinux-mount").run();
}

#[tauri::command]
pub async fn test_partitioning() {
    let blueprint = get_blueprint_from_opt().await;
    let blueprint: BluePrint = serde_json::from_str(&blueprint).unwrap();

    match partitioning(&blueprint).await {
        Ok(_) => println!("Partitioning Successful"),
        Err(e) => println!("Huh, as expected: {:#?}", e),
    }
}

pub async fn partitioning(blueprint: &BluePrint) -> Result<(), Error> {
    let mut result = Ok(());

    if let Some(storage) = blueprint.storage.as_ref() {
        match storage.install_method {
            MethodKind::SINGLE => {
                if storage.autogenerated {
                    if let Some(storage_val) = blueprint.storage.clone() {
                        let storage_data: tea_partition_generator::blueprint::Storage =
                            storage_val.into();

                        let method = storage_data.clone();

                        Partgen::do_dangerous_task_on(storage_data.clone(), method.install_method);
                        let mnt = MountPoint::new(storage_data.clone());
                        mnt.mount_all();
                    }
                } else {
                    result = partitioning_layout_preserved(blueprint);
                }
            }
            MethodKind::DUAL => {
                if storage.autogenerated {
                    if let Some(storage_val) = blueprint.storage.clone() {
                        let storage_data: tea_partition_generator::blueprint::Storage =
                            storage_val.into();

                        let method = storage_data.clone();

                        Os::mkdisk_uninitalized(
                            // FIXME: remove dangerous unwrap in future
                            storage_data.original_sector.clone().unwrap().start.unwrap(),
                            storage_data.original_sector.clone().unwrap().end.unwrap(),
                            storage_data.disk_path.clone().unwrap(),
                        );

                        Partgen::do_dangerous_task_on(storage_data.clone(), method.install_method);
                        let mnt = MountPoint::new(storage_data.clone());
                        mnt.mount_all();
                    }
                } else {
                    result = partitioning_layout_preserved(blueprint);
                }
            }
            MethodKind::MANUAL => {
                if storage.new_partition_table {
                    result = partitioning_new_partition_table(blueprint).await;
                } else {
                    result = manual_partitioning(blueprint).await
                }
            }
        }
    }

    result
}

async fn partitioning_new_partition_table(blueprint: &BluePrint) -> Result<(), Error> {
    force_umount();

    let disk_path = &blueprint.storage.as_ref().unwrap().disk_path;
    let partition_table = &blueprint.storage.as_ref().unwrap().partition_table;
    let partitions = blueprint.storage.as_ref().unwrap().partitions.clone();

    let firmware_type = &blueprint.bootloader.as_ref().unwrap().firmware_type;
    let bootloader_path = &blueprint.bootloader.as_ref().unwrap().path;

    create_new_partition_table(
        disk_path.as_ref().unwrap(),
        partition_table.as_ref().unwrap(),
    )?;

    println!("create new partition table done");

    let formatted_partitions =
        get_formatted_partitions(disk_path.as_ref().unwrap(), partitions.as_ref().unwrap(), true).await?;

    let formatted_partitions_json = serde_json::to_string(&formatted_partitions).expect("Failed to parse Vec<Partition> into String!");

    blueprint_set_partition(formatted_partitions_json)?;

    println!("partitioning done");

    actual_partitioning(Some(formatted_partitions))?;

    Ok(())
}

fn is_intersect(r1: std::ops::RangeInclusive<u64>, r2: std::ops::RangeInclusive<u64>) -> bool {
    let start = std::cmp::max(r1.start(), r2.start());
    let end = std::cmp::min(r1.end(), r2.end());

    start <= end
}

async fn get_formatted_partitions(
    disk_path: &str,
    partitions: &Vec<Partition>,
    new_partition_table: bool
) -> Result<Vec<Partition>, Error> {
    let mut temp_partitions: Vec<Partition> = Vec::new();
    let disk = get_read().disk;
    let actual_disk = disk
        .iter()
        .find(|disk| disk.disk_path.clone().unwrap() == *disk_path);

    let mut deleted_partitions: Vec<u64> = Vec::new();

    for partition in partitions {
        let mut path: Option<String> = partition.path.clone();

        if partition.format {
            println!("asked to format");
            if !new_partition_table
            {
                let actual_partition = actual_disk.as_ref().unwrap().partitions.as_ref().unwrap();
                
                for actual in actual_partition {
                    let number = actual
                        .number
                        .clone()
                        .unwrap_or("0".into())
                        .parse::<u64>()
                        .unwrap();
                    let start_sector = actual
                        .start
                        .as_ref()
                        .unwrap()
                        .trim_end_matches("s")
                        .parse::<u64>()
                        .unwrap();
                    let end_sector = actual
                        .end
                        .as_ref()
                        .unwrap()
                        .trim_end_matches("s")
                        .parse::<u64>()
                        .unwrap();

                    if number != 0
                        && !deleted_partitions.contains(&number)
                        && is_intersect(partition.start..=partition.end, start_sector..=end_sector)
                    {
                        println!("about to format {}", number);
                        deleted_partitions.push(number);
                        cmd!(
                            "parted",
                            "--script",
                            partition.disk_path.as_ref().unwrap(),
                            "rm",
                            number.to_string()
                        )
                        .run()?;
                        println!("its formatted");
                    }
                }
            }

            println!("it's done");

            path = format_unallocated(
                disk_path,
                partition.start,
                partition.end,
                partition.filesystem.as_deref(),
                partition.label.clone(),
            )?;
        }

        temp_partitions.push(Partition {
            path: path.to_owned(),
            ..partition.to_owned()
        });

        if let Some(flags) = &partition.flags
        {
            for flag in flags
            {
                if path.is_some()
                {
                    let number = get_number_from_path(disk_path, path.as_ref().unwrap())
                        .map(|n| n.to_string());

                    if let Some(number) = number
                    {
                        cmd!("parted", disk_path, "set", number, flag, "on").run()?;
                    }
                }
            }
        }

    }

    Ok(temp_partitions)
}

async fn manual_partitioning(blueprint: &BluePrint) -> Result<(), Error> {
    let disk_path = &blueprint.storage.as_ref().unwrap().disk_path;
    let partition_table = &blueprint.storage.as_ref().unwrap().partition_table;
    let partitions = blueprint.storage.as_ref().unwrap().partitions.clone();

    let formatted_partitions =
        get_formatted_partitions(disk_path.as_ref().unwrap(), partitions.as_ref().unwrap(), false).await?;

    println!("partitioning done");

    actual_partitioning(Some(formatted_partitions))?;

    Ok(())
}

fn partitioning_layout_changed(blueprint: &BluePrint) -> Result<(), Error> {
    todo!();
}

fn partitioning_layout_preserved(blueprint: &BluePrint) -> Result<(), Error> {
    force_umount();

    let firmware_type = &blueprint.bootloader.as_ref().unwrap().firmware_type;
    let bootloader_path = &blueprint.bootloader.as_ref().unwrap().path;

    let partitions = blueprint
        .storage
        .as_ref()
        .unwrap()
        .partitions
        .as_ref()
        .unwrap();

    actual_partitioning(Some(partitions.to_vec()))?;

    match firmware_type {
        FirmwareKind::UEFI => {
            create_dir_all("/tealinux-mount/boot/efi")?;
            mount(
                &bootloader_path.as_ref().unwrap(),
                "/tealinux-mount/boot/efi",
                None,
            )?;
        }

        FirmwareKind::BIOS => (),
    }

    Ok(())
}

pub fn get_boot_mountpoint(blueprint: &BluePrint) -> Option<String> {
    let disk = &blueprint.storage.as_ref().unwrap().partitions;
    let mut boot_mountpoint = None;

    if let Some(disk) = disk {
        let boot_mountpoint_index = disk.iter().position(|f| {
            f.mountpoint.is_some() && f.mountpoint.as_ref().unwrap().contains("boot")
        });

        if let Some(index) = boot_mountpoint_index {
            boot_mountpoint = Some(disk[index].mountpoint.as_ref().unwrap());
        }
    }

    boot_mountpoint.cloned()
}

pub fn get_boot_path(blueprint: &BluePrint) -> Option<String> {
    let disk = &blueprint.storage.as_ref().unwrap().partitions;
    let mut boot_path = None;

    if let Some(disk) = disk {
        let boot_path_index = disk.iter().position(|f| {
            f.path.is_some()
                && f.mountpoint.is_some()
                && f.mountpoint.as_ref().unwrap().contains("boot")
        });

        if let Some(index) = boot_path_index {
            boot_path = Some(disk[index].path.as_ref().unwrap());
        }
    }

    boot_path.cloned()
}

pub fn get_bios_grub_path(blueprint: &BluePrint) -> Option<String> {
    let partitions = &blueprint.storage.as_ref().unwrap().partitions;
    let mut bios_grub_path = None;

    if let Some(partition) = partitions {
        let bios_grub_path_index = partition.iter().position(|f| {
            f.path.is_some()
            && f.flags.is_some()
            && f.flags.as_ref().unwrap().contains(&"bios_grub".to_string())
        });

        if let Some(index) = bios_grub_path_index {
            bios_grub_path = Some(partition[index].path.as_ref().unwrap());
        }
    }

    bios_grub_path.cloned()
}

fn actual_partitioning(partitions: Option<Vec<Partition>>) -> Result<(), Error> {
    if !Path::exists(Path::new("/tealinux-mount")) {
        std::fs::create_dir("/tealinux-mount/")?
    }

    match partitions {
        Some(partitions) => {
            // Find partition that assigned as root, and deal with it first

            let root = partitions
                .iter()
                .find(|p| p.mountpoint.as_ref().is_some_and(|m| m.eq("/")));

            let home = partitions
                .iter()
                .find(|p| p.mountpoint.as_ref().is_some_and(|m| m.eq("/home")));

            println!("Checking if root is available");

            if let Some(root) = root {
                println!("It's available");
                let mut path: Option<String> = root.to_owned().path;

                println!("Checking if the root partition is unallocated");
                if root.format && root.path.is_none() && root.filesystem.is_some() {
                    println!("Unallocated root detected! Formatting unallocated partition");
                    path = format_unallocated(
                        root.disk_path.as_ref().unwrap(),
                        root.start,
                        root.end,
                        root.filesystem.as_deref(),
                        root.label.clone(),
                    )?;
                } else if root.format && root.path.is_some() && root.filesystem.is_some() {
                    println!("Formatting the already allocated root");
                    format(
                        root.filesystem.as_ref().unwrap(),
                        root.path.as_ref().unwrap(),
                        root.label.as_deref(),
                    )?;
                }

                if let Some(filesystem) = root.to_owned().filesystem {
                    mount(path.as_ref().unwrap(), "/tealinux-mount", None)?;

                    if home.is_none() && filesystem.eq("btrfs") {
                        create_subvolume("/tealinux-mount/@")?;
                        create_subvolume("/tealinux-mount/@home")?;

                        umount("/tealinux-mount")?;

                        mount_subvolume("@", path.as_ref().unwrap(), "/tealinux-mount")?;

                        create_dir("/tealinux-mount/home")?;

                        mount_subvolume("@home", path.as_ref().unwrap(), "/tealinux-mount/home")?;
                    }
                }

                println!("Done dealing with root");
            }

            // Deal with rest of the partition

            println!("Dealing with the rest of the partition");
            for i in partitions {
                if let Some(mountpoint) = i.to_owned().mountpoint {
                    // Ignore root

                    if !mountpoint.eq("/") {
                        if mountpoint.contains("swap") {
                            cmd!("swapon", i.path.as_ref().unwrap()).run()?;
                        }

                        if mountpoint.contains("boot") {
                            cmd!(
                                "mkdir",
                                "--parents",
                                format!("/tealinux-mount{}", mountpoint)
                            )
                            .run()?;
                            mount(
                                i.path.as_ref().unwrap(),
                                &format!("/tealinux-mount{}", mountpoint),
                                None,
                            )?;
                        }
                    }
                }
            }

            Ok(())
        }
        None => Err(Error::from(ErrorKind::NotFound)),
    }
}
